%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%% INSERINDO COMENTÁRIOS EM ARQUIVOS .bib %%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% 1. Como em outros arquivos LaTeX, comentários são iniciados por "%" e,
%    portanto, é preciso usar "\%" para imprimir o caractere "%". Esquecer
%    disso pode gerar erros difíceis de encontrar!
%
% 2. Não é possível inserir comentários dentro de uma entrada, apenas fora.
%
% 3. Não é possível incluir o caractere arroba em um comentário.
%
% 4. Se quiser desabilitar temporariamente um campo ("comentar" o campo),
%    troque seu nome para algum nome inválido, como "author-disable".
%    Se quiser fazer alguma observação permanente dentro de uma entrada,
%    você também pode usar algum nome de campo inválido, como "lembrete",
%    ou usar o campo "annotation", que normalmente é ignorado.
%
% 5. Se quiser desabilitar temporariamente uma entrada inteira ("comentar" a
%    entrada), não basta colocar "%" nas linhas correspondentes por causa do
%    caractere arroba; também é preciso remover a arroba.
%
% 6. Na verdade, as regras não são bem essas, mas segui-las é uma boa ideia:
%    https://tex.stackexchange.com/a/262282


% Esta entrada está comentada, ou seja, não tem efeito: se houvesse uma
% referência a ela no texto, a referência ficaria inválida. Observe que,
% para isso, o caractere arroba foi apagado!
%Book{JW82,
% author    = {Richard A. Johnson and Dean W. Wichern},
% title     = {Applied Multivariate Statistical Analysis},
% publisher = {Prentice-Hall},
% year      = {1983}
%}

@inproceedings{10.1145/800076.802464,
    author    = {Sleator, Daniel D. and Tarjan, Robert E.},
    title     = {A Data Structure for Dynamic Trees},
    year      = {1981},
    isbn      = {9781450373920},
    address   = {New York, NY, USA},
    url       = {https://doi.org/10.1145/800076.802464},
    doi       = {10.1145/800076.802464},
    abstract  = {We propose a data structure to maintain a collection of vertex-disjoint trees under a sequence of two kinds of operations: a link operation that combines two trees into one by adding an edge, and a cut operation that divides one tree into two by deleting an edge. Our data structure requires O(log n) time per operation when the time is amortized over a sequence of operations. Using our data structure, we obtain new fast algorithms for the following problems:(1) Computing deepest common ancestors.(2) Solving various network flow problems including finding maximum flows, blocking flows, and acyclic flows.(3) Computing certain kinds of constrained minimum spanning trees.(4) Implementing the network simplex algorithm for the transshipment problem.Our most significant application is (2); we obtain an O(mn log n)-time algorithm to find a maximum flow in a network of n vertices and m edges, beating by a factor of log n the fastest algorithm previously known for sparse graphs.},
    booktitle = {Proceedings of the Thirteenth Annual ACM Symposium on Theory of Computing (STOC)},
    pages     = {114-122},
    numpages  = {9}
}

@article{10.1145/3828.3835,
    author     = {Sleator, Daniel D. and Tarjan, Robert E.},
    title      = {Self-Adjusting Binary Search Trees},
    year       = {1985},
    issue_date = {July 1985},
    publisher  = {Association for Computing Machinery},
    address    = {New York, NY, USA},
    volume     = {32},
    number     = {3},
    issn       = {0004-5411},
    url        = {https://doi.org/10.1145/3828.3835},
    doi        = {10.1145/3828.3835},
    abstract   = {The splay tree, a self-adjusting form of binary search tree, is developed and analyzed. The binary search tree is a data structure for representing tables and lists so that accessing, inserting, and deleting items is easy. On an n-node splay tree, all the standard search tree operations have an amortized time bound of O(log n) per operation, where by “amortized time” is meant the time per operation averaged over a worst-case sequence of operations. Thus splay trees are as efficient as balanced trees when total running time is the measure of interest. In addition, for sufficiently long access sequences, splay trees are as efficient, to within a constant factor, as static optimum search trees. The efficiency of splay trees comes not from an explicit structural constraint, as with balanced trees, but from applying a simple restructuring heuristic, called splaying, whenever the tree is accessed. Extensions of splaying give simplified forms of two other data structures: lexicographic or multidimensional search trees and link/cut trees.},
    journal    = {J. ACM},
    pages      = {652-686},
    numpages   = {35}
}

@article{10.1145/1240233.1240236,
    author     = {Demaine, Erik D. and Iacono, John and Langerman, Stefan},
    title      = {Retroactive Data Structures},
    year       = {2007},
    issue_date = {May 2007},
    publisher  = {Association for Computing Machinery},
    address    = {New York, NY, USA},
    issn       = {1549-6325},
    url        = {https://doi.org/10.1145/1240233.1240236},
    doi        = {10.1145/1240233.1240236},
    abstract   = {We introduce a new data structuring paradigm in which operations can be performed on a data structure not only in the present, but also in the past. In this new paradigm, called retroactive data structures, the historical sequence of operations performed on the data structure is not fixed. The data structure allows arbitrary insertion and deletion of operations at arbitrary times, subject only to consistency requirements. We initiate the study of retroactive data structures by formally defining the model and its variants. We prove that, unlike persistence, efficient retroactivity is not always achievable. Thus, we present efficient retroactive data structures for queues, doubly ended queues, priority queues, union-find, and decomposable search structures.},
    journal    = {ACM Trans. Algorithms},
    numpages   = {20},
    keywords   = {point location, time travel, persistence, History, rollback}
}

@article{10.1145/364099.364331,
    author     = {Galler, Bernard A. and Fisher, Michael J.},
    title      = {An Improved Equivalence Algorithm},
    year       = {1964},
    issue_date = {May 1964},
    publisher  = {Association for Computing Machinery},
    address    = {New York, NY, USA},
    volume     = {7},
    number     = {5},
    issn       = {0001-0782},
    url        = {https://doi.org/10.1145/364099.364331},
    doi        = {10.1145/364099.364331},
    abstract   = {An algorithm for assigning storage on the basis of EQUIVALENCE, DIMENSION and COMMON declarations is presented. The algorithm is based on a tree structure, and has reduced computation time by 40 percent over a previously published algorithm by identifying all equivalence classes with one scan of the EQUIVALENCE declarations. The method is applicable in any problem in which it is necessary to identify equivalence classes, given the element pairs defining the equivalence relation.},
    journal    = {Commun. ACM},
    pages      = {301-303},
    numpages   = {3}
}

@article{10.1145/62.2160,
    author     = {Tarjan, Robert E. and van Leeuwen, Jan},
    title      = {Worst-Case Analysis of Set Union Algorithms},
    year       = {1984},
    issue_date = {April 1984},
    publisher  = {Association for Computing Machinery},
    address    = {New York, NY, USA},
    volume     = {31},
    number     = {2},
    issn       = {0004-5411},
    url        = {https://doi.org/10.1145/62.2160},
    doi        = {10.1145/62.2160},
    journal    = {J. ACM},
    pages      = {245-281},
    numpages   = {37}
}

@article{10.1093/comjnl/bxaa135,
    author  = {de Andrade Júnior, José Wagner and Duarte Seabra, Rodrigo},
    title   = {{Fully Retroactive Minimum Spanning Tree Problem}},
    journal = {The Computer Journal},
    volume  = {65},
    number  = {4},
    pages   = {973-982},
    year    = {2020},
    month   = {12},
    issn    = {0010-4620},
    doi     = {10.1093/comjnl/bxaa135},
    url     = {https://doi.org/10.1093/comjnl/bxaa135},
    eprint  = {https://academic.oup.com/comjnl/article-pdf/65/4/973/43377476/bxaa135.pdf}
}

@article{10.1145/502090.502095,
    author     = {Holm, Jacob and de Lichtenberg, Kristian and Thorup, Mikkel},
    title      = {Poly-Logarithmic Deterministic Fully-Dynamic Algorithms for Connectivity, Minimum Spanning Tree, 2-Edge, and Biconnectivity},
    year       = {2001},
    issue_date = {July 2001},
    publisher  = {Association for Computing Machinery},
    address    = {New York, NY, USA},
    volume     = {48},
    number     = {4},
    issn       = {0004-5411},
    url        = {https://doi.org/10.1145/502090.502095},
    doi        = {10.1145/502090.502095},
    abstract   = {Deterministic fully dynamic graph algorithms are presented for connectivity, minimum spanning tree, 2-edge connectivity, and biconnectivity. Assuming that we start with no edges in a graph with n vertices, the amortized operation costs are O(log2 n) for connectivity, O(log4 n) for minimum spanning forest, 2-edge connectivity, and O(log5 n) biconnectivity.},
    journal    = {J. ACM},
    month      = {jul},
    pages      = {723–760},
    numpages   = {38},
    keywords   = {dynamic graph algorithms, 2-edge connectivity, connectivity, minimum spanning tree, Biconnectivity}
}

 @misc{demaine_holmgren_jian_stepanenko_ishaque,
    title  = {6.851: Advanced Data Structures Spring 2012 - Lecture 19},
    url    = {https://courses.csail.mit.edu/6.851/spring12/scribe/L19.pdf},
    author = {Demaine, Erik D. and Holmgren, Justin and Jian, Jing and Stepanenko, Maksim and Ishaque, Mashhood},
    year   = {2012}
}

@article{frederickson1985data,
    title     = {Data structures for on-line updating of minimum spanning trees, with applications},
    author    = {Frederickson, Greg N.},
    journal   = {SIAM Journal on Computing},
    volume    = {14},
    number    = {4},
    pages     = {781--798},
    year      = {1985},
    publisher = {SIAM}
}

@article{6773228,
    author  = {Prim, R. C.},
    journal = {The Bell System Technical Journal},
    title   = {Shortest connection networks and some generalizations},
    year    = {1957},
    volume  = {36},
    number  = {6},
    pages   = {1389-1401},
    doi     = {10.1002/j.1538-7305.1957.tb01515.x}
}

@article{kruskal1956shortest,
    title     = {On the shortest spanning subtree of a graph and the traveling salesman problem},
    author    = {Kruskal, Joseph B.},
    journal   = {Proceedings of the American Mathematical Society},
    volume    = {7},
    number    = {1},
    pages     = {48--50},
    year      = {1956},
    publisher = {JSTOR}
}

@article{hanauer2021recent,
    title   = {Recent advances in fully dynamic graph algorithms},
    author  = {Hanauer, Kathrin and Henzinger, Monika and Schulz, Christian},
    journal = {arXiv preprint arXiv:2102.11169},
    year    = {2021}
}

@article{DBLP:journals/corr/abs-1910-03332,
    author     = {Monika Henzinger and
                  Xiaowei Wu},
    title      = {Upper and Lower Bounds for Fully Retroactive Graph Problems},
    journal    = {CoRR},
    volume     = {abs/1910.03332},
    year       = {2019},
    url        = {http://arxiv.org/abs/1910.03332},
    eprinttype = {arXiv},
    eprint     = {1910.03332},
    timestamp  = {Fri, 16 Oct 2020 09:37:13 +0200},
    biburl     = {https://dblp.org/rec/journals/corr/abs-1910-03332.bib},
    bibsource  = {dblp computer science bibliography, https://dblp.org}
}

@inproceedings{10.1007/978-3-540-69903-3_16,
    author    = {Demaine, Erik D.
                 and Langerman, Stefan
                 and Price, Eric},
    editor    = {Gudmundsson, Joachim},
    title     = {Confluently Persistent Tries for Efficient Version Control},
    booktitle = {Scandinavian Workshop on Algorithm Theory (SWAT)},
    year      = {2008},
    publisher = {Springer},
    pages     = {160--172},
    abstract  = {We consider a data-structural problem motivated by version control of a hierarchical directory structure in a system like Subversion. The model is that directories and files can be moved and copied between two arbitrary versions in addition to being added or removed in an arbitrary version. Equivalently, we wish to maintain a confluently persistent trie (where internal nodes represent directories, leaves represent files, and edge labels represent path names), subject to copying a subtree between two arbitrary versions, adding a new child to an existing node, and deleting an existing subtree in an arbitrary version.},
    isbn      = {978-3-540-69903-3}
}

 @misc{sqrt-decomp,
    author  = {CP-Algorithms},
    title   = {Square root decomposition},
    url     = {https://cp-algorithms.com/data_structures/sqrt_decomposition.html},
    journal = {Algorithms for Competitive Programming},
    year    = {2022},
    urldate = {2022-07-09}
} 

@book{10.5555/1614191,
    author    = {Cormen, Thomas H. and Leiserson, Charles E. and Rivest, Ronald L. and Stein, Clifford},
    title     = {Introduction to Algorithms, Third Edition},
    year      = {2009},
    isbn      = {0262033844},
    publisher = {The MIT Press},
    abstract  = {If you had to buy just one text on algorithms, Introduction to Algorithms is a magnificent choice. The book begins by considering the mathematical foundations of the analysis of algorithms and maintains this mathematical rigor throughout the work. The tools developed in these opening sections are then applied to sorting, data structures, graphs, and a variety of selected algorithms including computational geometry, string algorithms, parallel models of computation, fast Fourier transforms (FFTs), and more. This book's strength lies in its encyclopedic range, clear exposition, and powerful analysis. Pseudo-code explanation of the algorithms coupled with proof of their accuracy makes this book is a great resource on the basic tools used to analyze the performance of algorithms.}
}

@book{sarnak1986persistent,
    title     = {Persistent data structures},
    author    = {Sarnak, Neil I.},
    year      = {1986},
    publisher = {New York University}
}

@article{agarwalimplementation,
    title   = {Implementation, Analysis and Application of Retroactive Data Structures},
    journal = {International Conference on Advances in Computer Science and Electronics Engineering},
    month   = {02},
    author  = {Agarwal, Suneeta and Panwaria, Prakhar},
    pages   = {88--92},
    year    = {2012},
    doi     = {10.15224/978-981-07-1403-1-247},
    isbn    = {978-981-07-1403-1}
}